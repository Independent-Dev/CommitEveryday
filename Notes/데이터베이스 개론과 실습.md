# 데이터베이스 개론과 실습

## 1.데이터베이스 시스템의 개념
***
### 1)데이터베이스 시스템
#### 기본
- **데이터베이스란**: 각 조직에 필요한 정보를 처리하기 위해 논리적으로 연관된 데이터를 모아 구조적으로 통합(중복을 없애고, 그렇게 함으로써 데이터를 간결하게 하고 불일치를 막고)해놓은 것. 
- **데이터베이스 시스템의 3요소**
  - **DBMS(Database Management System)**:  데이터베이스 관리 시스템, 사용자와 데이터베이스를 연결시켜주는 소프트웨어, 주기억장치에 위치함. 
  - **데이터베이스**: 데이터를 모아놓은 토대, 실질적으로 데이터가 존재하는 곳, 하드디스크에 저장됨. 
  - **데이터 모델**: 데이터가 저장되는 스타일 또는 데이터가 저장되는 기법. 눈에 보이지 않는 논리적인 개념.

#### 파일시스템과 데이터베이스
- **파일시스템**: 파일 서버에 저장된 데이터를 사용하기 위해 각 컴퓨터의 응용 프로그램에서 **열기/닫기(open/close)**를 요청. 각 **응용 프로그램에서 독립적으로 파일을 다루므로** 데이터가 중복될 수 있으며, 데이터의 일관성 역시 보장할 수 없음.
- **DBMS**: DBMS(DBMS 서버)가 독점적으로 파일을 다루며(응용 프로그램은 DBMS에 파일을 요청), 데이터의 일관성 유지, 복구, 동시 접근 제어 등의 기능을 수행함. -->데이터의 중복을 줄이고, 데이터를 표준화하여 무결정을 유지함. 
  - + 파일 시스템은 데이터의 내용을 관리할 수 있는 (java 든 c든) 특정 프로그램을 기초로 돌아가는데, 이때 데이터의 내용이 아닌 데이터의 구조가 변경되었을 때에는 프로그램 자체를 손보아야 하지만, DBMS는 데이터 구조를 만들고, 변경할 수 있는 기능을 제공하여 그렇게 하지 않아도 됨.  
  - _이것이 규모가 커지면 하나의 DBMS가 아니라 분산 DBMS를 운영하는 시스템으로 전환된다고 하는데 이것이 구체적으로 어떻게 동작하는지는 여쭤보아야 할 것 같다..._

#### 데이터베이스 시스템의 구성 심화
- **DBMS**: SQL을 번역하는 DML/DDL 컴파일러와 응용 프로그램에 삽입된 SQL을 번역하는 Embedded DML 컴파일러, 번역된 SQL을 처리하는 알고리즘인 질의처리기가 있음. 그외에 트랜잭션을 관리하는 트랜잭션(데이터베이스를 처리하는 프로그램의 단위...?) 관리자, 파일을 관리하는 파일 관리자, 버퍼 관리자가 있음. 
- **데이터베이스**: 실질적인 데이터라고 할 수 있는 데이터 파일과 데이터에 빠르게 접근하기 위한 인덱스, 데이터에 대한 정보를 저장하는 데이터 사전을 저장하고 있음. 
- **데이터 모델**: 데이터베이스에 데이터가 구조화되어 저장된 방식. 데이터 모델을 구분하는 가장 큰 기준은 **데이터들 간의 관계를 표현하는 방법**. 여기에는 크게 3가지 방법이 있을 수 있음.
  1. 포인터 사용(계층 데이터 모델, 네트워크 데이터 모델): 다른 테이블의 연관된 튜플의 포인터 값을 저장하는 방식
    - 학생(학번, 이름, 강좌 포인터) // 강좌(강좌 번호, 강좌 이름)
  2. 속성 값 사용(관계 데이터 모델): 속성값을 직접 저장하는 방식. 포인터를 사용하는 방법보다 속도는 조금 느리지만 개념이 쉽고 프로그램 개발이 빠르기 때문에 관계 데이터 모델을 비롯한 많은 데이터베이스 시스템에서 이 방법을 사용.
    - 학생(학번, 이름, 강좌 번호) // 강좌(강좌번호, 강좌 이름)
  3. 객체 식별자 사용(객체 데이터 모델): 각 튜플을 객체로 보고 객체의 고유 식별자인 오브젝트 아이디(oid)를 학생 테이블에 저장하는 방법. 객체 지향 언어의 상속, 캡슐화 등의 개념을 도입.
    - 학생(학번, 이름, objectid)//강좌(강좌번호, 강좌 이름)
  4. 요약: 관계 데이터 모델을 기본으로 객체 데이터 모델의 장점을 일부 수용한 객체-관계 데이터 모델로 발전하고 있음. 
    - _ORM은 어떤 형태라고 볼 수 있나..._
    - **ORM**: object-relation mapping. 객체와 테이블 사이에 존재하는 이질성을 극복하기 위해 객체와 테이블간의 관계를 설정하여 자동으로 처리하게 하는 것. 
- **데이터베이스의 개념적 구조**: 데이터베이스를 개념적으로 이해하기 위하여, 데이터베이스를 보는 관점을 세 개의 단계로 분리한 것. 
  - _나중에 볼 것_

### 2)관계 데이터 모델
#### 관계 데이터 모델의 개념
- _이 개념들은 명료하게 구분해서 쓰려고 노력하면서 익숙해질 필요가 있겠다..._
- **relation**: 행과 열로 구성된(조직된) 정보. 테이블은 릴레이션의 시각적 표현 방법. 칼럼 집합의 원소들이 맺은 관계(relationship)를 모아놓은 것이 데이터베이스 내의 하나의 테이블, relation.
  - relationship은 크게 2가지. relation들 간의 relationship, 튜플(row, 행)을 형성하는 relation 내의 그것.
- **스키마와 인스턴스**: 스키마는 각 열의 정보를 담고 있는 relation의 첫 행, 다른 말로 intension, 인스턴스는 스키마에 따라 테이블에 실제로 저장되는 데이터의 집합, 다른 말로 extension.
- **칼럼**: 칼럼은 다른 말로 **속성(attribute)**라고 하는데, 우리는 이것의 이름을 통해 거기에 어떤 정보가 담기는지를 대략적으로 파악할 수 있음. 칼럼이 가질 수 있는 값(제약조건, 자료형 등..)을 정의한 것이 **도메인(domain)**, 하나의 릴레이션이 가지는 속성의 개수가 **차수(degree)**.
- **row**: 다른 말로 tuple, 인스턴스의 각 행. 릴레이션에 저장된 튜플의 수를 cardinality라고 이야기함. 

#### 릴레이션의 특징
- 속성은 중복되어서는 안 되고(서로 다른 이름을 가져야 하고), 
- 한 속성의 도메인은 예외 없이 일관성이 있어야 하며, 
- 한 튜플 내에서 한 속성은 하나의 값만을 가질 수 있을 뿐. 복수의 값을 가질 수 없다. 
- 튜플 역시도 중복 불가, 달리 이야기하면 특정 튜플과 모든 속성값이 똑같은 튜플이 존재해서는 안 됨. 적어도 하나는 달라야 함. 

**관계 데이터베이스 시스템은 관계 데이터 모델에 기초하여 SQL을 기반으로 구현됨. 릴레이션의 생성과 관리를 SQL로 수행, 릴레이션에 대한 제약조건을 SQL로 표현, 릴레이션에서 데이터를 추출하는 연산을 SQL로 표현**

#### 무결성 제약조건
- 질의에 대한 신뢰성 있는 답을 제공하기 위해 데이터베이스의 무결성을 보장하는 장치 및 조건. 
##### 키
- 슈퍼키: 하나의 tuple을 유일하게 식별할 수 있는 하나의 속성 또는 속성의 부분집합. 따라서 슈퍼키는 포함하지 않아도 되는 속성을 포함할 수 있음. 
- **후보키**(candidate key): 필요조건이 아닌 속성을 제외한, 튜플을 식별할 수 있게 해주는 속성의 최소 집합.(ex: 고객 아이디와 고객 주민번호 등...)
- **기본키**(Primary Key): 여러 후보키 가운데 하나를 선정하여 대표로 삼는 키. 
  - 기본키 선정시 고려사항: Null값을 허용하지 않는 속성, 값의 변경이 일어나지 않는 소겅, 향후 키를 사용함에 있어 보안 등의 문제가 발생하지 않아야 함. 
- **대리키/인조키**(artificial key): 보안을 요하거나, 여러 개의 속성으로 구성되는 등 후보키 내에서 기본키를 발견할 수 없을 때 일련번호 같은 가상의 속성을 만들어 기본키로 삼는 경우가 있는데(주문번호 등...) 이러한 키를 대리키라고 함.
  - 대리키는 DBMS나 관련 소프트웨어에서 임의로 생성하는 값으로 사용자가 직관적으로 그 값의 의미를 알 수 없다-->_그러면 1씩 증가하는 id값은 대리키라고 할 수 없나...??_
- 대체키(alternate key): 기본키로 선정되지 않은 후보키. 
- **외래키**(Foreign key): (다른) 릴레이션의 기본키를 참조하는 속성(참조하는 키), 특정 릴레이션의 기본키가 다른 릴레이션에서는 외래키가 되는 것.
  - 여기서 괄호를 친 것에서 알 수 있듯, 자기 자신의 기본키를 참조하는 경우에도 특정 속성은 외래키라고 할 수 있다. 
  - 외래키는 기본키와 달리 **NULL** 값을 포함할 수 있고 **중복값**도 허용한다. ex) 학생이 어떤 강좌도 듣지 않는 경우 Null, 한 강좌를 여러 학생이 들으면 중복.  

##### 무결성 제약조건
- 데이터가 계속해서 무결성을 유지하려면 tuple의 삽입, 삭제, 수정 시 데이터의 제약조건 준수여부를 지속적으로 확인해야함. (이 작업을 진행하는 것이 DBMS의 핵심기능 가운데 하나임) 여기에는 크게 3가지가 있음. 
1. **도메인 무결성 제약조건**: 릴레이션 내의 튜플은 각 속성의 도메인에 지정된 값만을 가져야 한다는 조건, 데이터 형식,null 가는 여부, default 등을 사용하여 지정 가능. 
2. **개체 무결성 제약조건(기본키 제약)**: 기본키는 null 값을 가져서는 안 되며 릴레이션 내에 오직 하나의 값만 존재해야 한다는 조건.(+고유성 제약조건: 키 속성의 모든 값들은 서로 같은 값이 없어야 함)
3. **참조 무결성 제약조건(외래키 제약)**: 자식 릴레이션의 외래키는 부모 릴레이션의 기본키를 참조하게 되고, 그래야 하는데(부모 릴레이션에 없는 값을 외래키로 사용 불가), 자식 릴레이션의 외래키는 부모 릴레이션의 기본키와 도메인이 동일해야 하며, 자식 릴레이션의 값이 변경될 때 부모 릴레이션의 제약을 받음. 그와 더불어 자식 릴레이션에서 참조하고 있는 값을 부모 릴레이션에서 삭제하거나 다른 값으로 변경하려고 하면 거부됨. 
  - 이걸 좀 더 깊이 있게 이해할 필요가 있겠다...

#### 관계대수
- **관계대수**란 어떤 데이터를 어떻게 찾는지에 대한 처리 절차. 
- **관계해석**은 어떤 데이터를 찾는지만 명시하는 선언적 언어.
  - SQL 언어는 관계해석을 기반으로 하지만 DBMS 내부에서는 관계대수에 기반을 둔 연산을 수행하여 최종 결과 집합을 반환하게 된다. 
    - _sql 자체가 관계해석이기에 orm과 sql의 속도차이가 현저하지 않을 수 있는 것인가..._
    - "관계대수식은 연산자의 조합에 따라 절차는 다르지만 같은 결과를 낼 수 있다. DBMS 역시 사용자의 질의에 따라 내부에서 질의 최적화(Query Optimization) 과정을 거쳐 같은 결과를 내는 여러 대수식을 생성하고 그 중 가장 효율적인 대수식을 선택하여 처리한다."
    - _관계대수식은 더 공부해보기._