# Python 정리1

## 목차: 변수, 조건문, 반복문, 함수, 클래스, 모듈
### \*변수와 객체
***
- **변수명 선언규칙**
  1. 영문자(대, 소문자 구분), 숫자, 언더바(\_)를 사용할 수 있다.
  2. 첫 자리에는 숫자를 사용할 수 없다.
  3. 파이썬 키워드는 변수명으로 사용할 수 없다.

- **변수 선언**: variable = value

- **변수의 강제 삭제**
  - del(variable)로 강제 삭제 가능. 

- **언패킹**
  - a, b = [1, 2] -> a = 1, b = 2
  - b, a = a, b -> a = 2, b = 1, 치환을 이렇게 하면 매우 쉬움!!
  - 함수 반환형도 이런 방식으로 받을 수 있음 ex) for x, y in enumerate(list)

- **스코프**: 객체가 유효한 범위 또는 변수가 유효한 범위
  - 내장 스코프: 최상위 스코프, 내장 함수나 내장 변수 등 선언이나 import 하지 않아도 쓸 수 있는 함수나 변수가 정의되어 있는 스코프
  - 모듈 스코프: 함수 바깥.
  - 클래스와 인스턴스 스코프: 각각이 만들어지면 생성되는 스코프. 인스턴스 스코프는 클래스 스코프보다 하위에 위치한다.
    - 그렇기 때문에 인스턴스 스코프에서 클래스 스코프의 객체(생성자 함수에서 정의되지 않은 객체)를 이용할 수 있는 것임. 
  - 지역 스코프: 함수가 정의되면 만들어지는 스코프
  - 하위 스코프에서는 상위 스코프의 객체를 이용할 수 있지만, 반대는 허용되지 않음. 

- **변수와 객체에 대한 함수**
  - type(객체): 객체의 자료형을 알려주는 함수
  - isinstance(객체, 자료형): 객체의 자료형이 인수의 자료형과 일치하거나, 부모/자식 관계에 있을 때 True를 반환.

### \*조건문
***
- **if**
  - "if:" + 줄바꿈 이후 들여쓰기 
  - **수치 비교**: ==(같다), !=(다르다), <, >, >=, <=("=<"는 에러)
  - **문자열, 리스트 비교**: ==, != 이용.
  - **한 번에 여러 번 비교하기**: "and"나 "or", 그리고 괄호"()"를 이용하여 조건을 연결.  
  - **문자열, 리스트, 셋, 튜플, 딕트(키) 검색**: if target in object(문자열, 리스트, 셋, 튜플, 딕트)
  
- **else**
  - if가 아닌 경우. 
  - "else:" + 줄바꿈 이후 들여쓰기

- **elif**
  - if가 아닌 다른 조건, 또는 이전에 나오지 않은 다른 조건.
  - "elif:" + 줄바꿈 이후 들여쓰기
##### 파이썬에서는 서로 다른 자료형은 비교할 수 없다. SyntaxError를 일으키지는 않지만 기대한 결과를 얻기 위해서는 형변환 등의 조작이 필요함. 

- **True, False**
  - 파이썬 문법에서 False로 취급하는 것들
     1. None
     2. 0: 0, 0.0, 0.j
     3. 비어 있는 문자열, 리스트, 튜플, 셋

### \*반복문
***
- 반복문이 실행되는 블럭은 들여쓰기 필수.
#### for
- **for x in range(시작수(default=0), 끝수, 단위(default=1))**
  - for x in range(1, 10, 2): 1부터 2씩 추가하면서 10 이전까지(9까지) 숫자를 x라는 변수로 추출하라.
- **for x in list, tuple, set, dict** 등: in 뒤에 오는 데이터를 하나씩 x라는 변수로 추출하라.

#### while
- **선언**: "while 조건문:" + 줄바꿈 이후 들여쓰기 이후 작성, 조건을 탈출할 수 있는 요소를 블록 내에 포함. or 블록 내에 들어가면 무한루프 실행.
- ※파이썬에는 do while이 없는데 그 이유는 1)이건 while로 충분히 대체가 가능하고, do라는 예약어를 추가할 경우 호환성이 심각하게 손상될 수 있기 때문에.

#### break, continue, else
- **break**: 반복문 중단(이하 구문 실행x), 이후 벗어나기
- **continue**: 반복문 블록 내의 이하 구문 건너뛰기. 반복문을 벗어나지는 않는다.
- **else**: 반복문 이후 실행되는 구문. break로 반복문이 끝난 경우에는 실행하지 않는다. 

### \*함수
***
- **함수의 선언**: "def funcname(parameters(NN)):"+ 줄바꿈 이후 들여쓰기 이후 작성(+return dataOrVariable)
  - 선언시에 def funcname(parameter=1)과 같이 default 값을 줄 수 있음.
  - 매개 변수를 정확히 몇 개 받을지 모르는 경우에는 \*를 사용. 
    - ex) def funcname(a, b, \*variables) // funcname(a = 1, b = 2, 3, 4)(여기서 3, 4를 \*variables로 받음. print(\*variables)-> 3, 4. print(variables)->[3, 4])
      - \*는 리스트, 튜플, 셋, 딕트와 같은 자료형에서 데이터만 쏙 뽑아내는 것이라고 생각할 수 있을 것임. 
  - key:value 형식의 미정의 인수를 받고 싶은 경우에는 \*\*를 사용. 
    - ex) def funcname(a, b, \*\*args) // funcname(a = 1, b = 2, c = 3, d = 4)

- **함수의 호출방법**
  - 반환값이 없는 경우: funcname((실행에 요구되는)parameters)
  - 반환값이 있는 경우: variable = funcname((실행에 요구되는)parameters)
  - 두 경우 모두 호출시에는 순서에 유의해서 매개변수를 써야 한다. 
  - "parameter=value(or variable)"와 같은 식으로 특정 값이 정확히 어떤 매개변수인지 써놓으면 순서는 틀려도 상관없다. 
- **이름 붙이는 요령**: do_something과 같이 함수의 기능을 뜻하는 영어 동사와 명사를 조합하여 함수명을 만들면 알기 쉽다. 
- **함수 내의 변수**
  - 함수 내에서 변수를 선언할 경우 그것은 지역변수로서 함수 블록 바깥에서 사용할 수 없다(이 경우 **NameError**).
  - 함수 내에서는 함수 밖의 변수를 참조할 수 있다. 그렇지만 그 변수에 조작을 가할 수는 없다(그런 경우 **UnboundLocalError**)
  - 함수 밖의 변수에 조작을 가하기 위해서는 "global variable"이라고 함수 내에서 선언한다. 단, 한 행을 띄우고 조작을 해야지 global과 함께 값을 할당해서는 안 된다.(**SyntaxError**)

#### lambda식
- **선언**: lambda sequence: formula
  - 여기서 formula는 sequence 내의 개별 데이터를 사용한 식(반환값)
  - ex)
  - a = [1, 5, 4, 6, 2, 3, 9]
  - a.sort(key = lambda a: a*-1) =>[9, 6, 5, 4, 3, 2, 1]


### \*class
***
- **클래스 선언**: "def className(superClass, 없으면 이 괄호 전체는 안 써도 됨.):"+ 줄바꿈 이후 들여쓰기 이후 작성
- **메소드**
  - 함수는 모듈 내에 위치하는 것. 클래스 내부에 위치하는 함수는 메소드라고 함. 
  - 모든 메소드는 'self'라는 초기 인자를 무조건 받음. 굳이 self일 필요는 없지만 관행적으로 쓰는 것. self에 대입하는 인수는 호출시에 지정할 필요가 없다. 
  - _self를 썼을 때의 이점: 295page_
- **초기화 메소드**
  - **정의**: "def \_\_init\_\_(self, parameters(NN)):"+ 줄바꿈 이후 들여쓰기 이후 작성(self.prop1 = parameter1 등등...)
  - 인스턴스를 생성할 때 실행됨
- **인스턴스 생성**: instance = Class()
- **인스턴스 이용**
  - 입력: 메소드와 속성은 인스턴스 네임스페이스에서 입력(메소드의 경우엔 함수 할당, 속성은 값)과 변경 가능. 
  - 호출 및 참조: object.method(), object.property()(이게 가능한 건 인스턴스 네임스페이스가 클래스 네임스페이스를 참조할 수 있기 때문임)
  - 인스턴스 네임스페이스에 없는(당연히 클래스 네임스페이스에도 없음) 값을 참조하려고 하면 AttribueError 발생
- **\_\_slots\_\_=[추가를 허용한 속성명]**: 인스턴스 레벨에서의 속성 추가는 이 항목이 클래스 내에 존재할 때는 이 항목에서 정의한 것들에 대해서만 가능함. 그렇지 않으면 **AttributeError**
- **캡슐화**
  - 프로퍼티 앞에 \_ 하나 붙이기: 클래스 내부에서만 조작할 수 있음을 알리는 것
  - 프로퍼티 앞에 \_ 두 개 붙이기: 외부에서는 이 프로퍼티에 접근도 할 수 없음을 알리는 것
    - 이 프로퍼티에 접근하기 위해서는 getpropertyname이나 setpropertyname을 써야 한다. 
    - 그렇지만 그외에도 object.\_classname\_\_propertyname을 하면 접근, 변경 가능.
- **특수메소드**
  - 객체의 동작을 변경하거나 클래스의 성질에 맞춰 특별한 동작을 하게 할 경우에 특수 메소드가 사용됨. 객체의 자료형에 따라 기능이 다른 것처럼, 자료형에 맞는 특수 메소드가 갖춰져 있고, 객체 생성, 연산 등을 할 때 호출됨. 생성자 함수처럼 언더바 2개가 양 끝에 붙어있는 모양을 하고 있음.  
  - 여기에는 +, -와 같은 연산자를 사용하거나 str()과 같은 특정 함수들을 호출할 때 쓰이는 메소드들이 있음. 이들은 전부 dir(objectOrClass)로 확인이 가능하다. 
  - **tip**: 메소드를 만들 때 내장형을 상속해서 특수 메소드를 오버라이딩(연산자 오버라이딩)하므로써 빠르게 효과적인 클래스를 만들어낼 수 있다. 

#### 상속
- **상속 선언**: 클래스 생성시 매개변수로 슈퍼클래스 명 전달. ex) class Cube(Prism)
  - 상속을 하게 되면 슈퍼 클래스에 이미 선언된 메소드와 속성을 쓸 수 있고, 새로운 메소드와 속성을 서브클래스에서 추가 가능. 
- **메소드 오버라이딩**: 슈퍼클래스에 선언된 메소드를 서브클래스에서 다시 재정의하는 것. 
  - 오버라이딩 하지 않은 메소드는 상속됨. 
- **super()**: super()를 이용하면 슈퍼클래스를 얻어낼 수 있음. 
  - **super()는 두 가지 방법으로 이용 가능**
    1. 인수를 전달하지 않고 호출: ex)super().\_\_init\_\_()
    2. 인수를 전달: ex)parant_class = super(snakeClass, self)_슈퍼 클래스의 메소드를 이용할 때는 이렇게 생성해야 하나?? 아니면 1.의 방법으로도 할 수 있나??_

### \*모듈
***
- 모듈 = .py파일, 모듈명 = 모듈 파일 확장자 앞 부분. 
- 패키지 = 1)모듈(.py파일)이 모여 있고, 2)\_\_init\_\_.py파일을 가지고 있는 **폴더**
#### 내장 모듈
- **모듈의 사용**
  - import moduleName: moduleName.class() or moduleName.func()
  - import moduleName as mn: mn.class() or mn.func()
  - from moduleName import class(or func): class.func() or func() 등 
    - 이 방식을 쓸 때의 주의점: import 되는 class나 함수의 이름이 같을 경우 앞서 import 한 것이 뒤엣 것에 의해 덮어씌워짐. 이런 문제는 import \*를 했을 때 더 심해질 수 있음. 그러니 주의할 것!!  
- **내장 모듈 찾기(표준 라이브러리)**: http://docs.python.jp/3/
#### 모듈 생성과 이용
- **모듈명**
  1. 숫자로 시작하거나 확장자 앞에 도트를 포함한 파일명은 불가
  2. 가능한 알파벳 소문자로만. 
- **"if \_\_name\_\_=='\_\_main\_\_':"**: 블록 안에 쓰면 파일을 실행할 때만 실행하는 블록. 
  - "else:" 등 "if \_\_init()..." 블록 바깥에 코드를 쓰면 그건 import 되는 시점에 실행됨.
#### 2.서드파티 모듈
- 찾기: https://pypi.python.org/pypi 참조하기. 
- pip을 이용하여 설치
- Anaconda에 탑재된 conda라는 구조를 이용하면 파이썬의 pip에서는 설치하기 어려운 외부 모듈 가운데 자주 이용되는 것드을 간단하게 설치할 수 있음. **Anaconda 설치해보기!!!**
- 기능의 일부를 실현하기 위해 C 언어로 작성된 소스 코드를 컴파일할 필요가 있는 모듈도 있음. 그런 것을 위해서는 C 컴파일이라는 애플리케이션(C 컴파일러를 말하는 것인가)을 준비할 필요가 있음
- from \_\_future\_\_ import ... 향후 받아들여질 기능은 이렇게 해서 이용이 가능함. 336page


  