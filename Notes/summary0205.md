# Python 공부 내용 공유 자료

## 1.질문 받은 사항
#### 1-1.(비교적)잘 답변한 것
- list, set, dict(hash table)의 특징과 메소드
- 슬라이싱, 리스트 컴프리핸션
- flask와 django의 차이: 풀스택 프레임워크와 마이크로 프레임워크

#### 1-2.그러지 못한 것
- 변수에 값을 입력하면 메모리에서 일어나는 일
- iterator, generator
- tuple은 어떨 때 이용하고 어떤 이점이 있는지


## 1-2.에 대해 공부한 것
#### 1. 변수
  - 변수에 값을 저장하면 생기는 일: 변수(b)에 값(a)을 저장->메모리에 값이 저장되는 공간a`가 형성->변수b에 대한 메모리 공간c가 형성->c에 a`의 주소값이 들어감. a`의 주소값을 알기 위해서는 id(b)를 찍어보면 됨. 
  - mutable과 immutable의 구분: 
    - mutable 자료형은 변수가 저장하는 값이 변해도 값의 주소는 변하지 않는 것. ex)list, set, dict
    - immutable은 변경 불가. 그러므로 기존의 immutable 객체가 들어 있던 변수에 = 연산자를 사용하면 새로운 객체가 할당됨, 다시 말하면, 새로운 객체의 주소가 변수의 메모리 공간에 들어감. ex)int, float, string, tuple // 이게 string에서 reversed()를 썼을 때 reverse object가 반환되는 이유.
    - shallow copy: 바로 이점 때문에 immutable 자료형은 사실상 deep copy. 가리키는 객체의 주소가 같다고 해도 객체의 값에 조작을 가하는 순간 재할당이 일어나기 때문에 shallow copy로 인한 의도하지 않은 값의 변경은 일어날 수 없음. 그렇지만 immutable은 값을 조작한다고 변수의 메모리에 저장된 객체의 주소값이 바뀌지 않으므로 shallow copy를 주의해야 함.
    - 피하는 방법: 각 자료형마다 나름의 방법이 있지만 모두가 공통으로 가지고 있는 copy() 메소드를 사용하면 됨.
  - 아직 모르는 것: 정수형에서 자주 쓰는 -5~255까지는 값을 분리해서 할당해도 같은 객체가 들어가는 건 아는데, 다른 자료형의 경우에는 어떠한지 등... 메모리 작동방식 더 잘 알 필요가 있다

#### 2.iterator, generator
  - **지연평가(lazy evaluation): Iterator**
    - 지연평가(lazy evaluation): 평가를 늦추고 필요할 때 값을 계산해주는 것
    - iterator: 지연평가 객체, generator: 특정한 방식(yield 키워드를 사용하는)으로 생성한 iterator
    - iterator 사용의 이점: 특정 주소에 있는 데이터를 컴퓨터가 RAM에 올려놓으면 메모리에 부담이 큼. 그래서 iterator는 lazy하게 요청받으면 해당 데이터만을 RAM에 올려놓음. so 메모리 사용량 측면에서 많은 이득이 있고, 이 이득은 데이터의 크기에 비례함.
    - iterator 객체를 만드는 방법:
      1. for문의 시퀀스로 내장 자료구조를 이용할 때 파이썬이 자동으로 변환///
      2. 내장함수인 iter_object = iter(seq)를 사용. 다음 요소를 얻으려면 next(iter_object)를 이용.
      3. 생성자 표현식 이용: iter_object = (x\*\*2 for x in range(1, 10)), 사용 방법은 위와 동일
  - **지연평가(lazy evaluation): Generator**
    - iterator와의 차이: 표면적으로는 iterator는 sequence, generator는 function. 더 보자면, iterator는 sequence가 건내주는 값을 (수동적으로) 처리해주지만, yield를 사용하면 어느 지점에서 어떤 값을 다룰지 더 세세하게 지정할 수 있다는 점이 차이인 것 같다. 이 부분을 잘못 이용하면 generator는 지연 평가의 이점을 전혀 누리지 못할 수도 있을 거라고 생각한다.
    - 예시: yield_book.py, yield_revision.py

#### 3.tuple
  - 위도와 경도와 같은 성질이 다르고 불변하는 수치를 표현할 때
  - 리스트와는 달리 튜플은 set과 dict의 키에 사용될 수 있음. 
    - 이게 핵심인 것 같다. 튜플은 성질이 다른 데이터의 표현처럼 독자적 자료형으로 쓰이기도 하지만, 다른 자료형의 쓰임을 안정적으로 확장하는데 그 의미가 있다고 생각할 수 있을 것 같다. 

## 그외 새롭게, 더 확실하게 알게 된 것
  - **python의 변수**: 메모리 주소를 가지는 모든 것은 변수를 가질 수 있고, 변수에 할당가능함!!->그렇기에 다이나믹 타이핑도 가능하고, 변수에 어떤 크기의 값이든 넣을 수 있음.
  - **python에서 객체의 의미**. property(속성, 메소드)를 가지고 있고 가질 수 있는 것->모든 것, dir()을 했을 때 아무것도 안 나오는 것은 파이썬에 아무것도 없음. 
  - **네임스페이스(클래스, 인스턴스, 함수), 매개변수(call by value), global(call by reference), 그리고 for이나 if는 별도의 네임스페이스가 아니라는 것**  
  - **mutable은 자료구조 내에서 중복을 불허하는 항목(dict의 key, set의 요소)이 될 수 없다는 것**
  - 다른 언어(java 등)에서는 문자열과 숫자의 연산이 가능하지만 python에서는 절대 불가!! 반드시 숫자를 문자로 변한하든, 문자를 숫자로 변환하든 해서 접근할 것
  - **For에서 else문을 사용하는 방법**
  - python에서는 if에서 &, |과 같은 기호들을 쓰지 않고 set의 연산자로 사용함
  - 클래스를 만들 때 아무런 처리도 하지 않을 때에는 **pass** 예약어 쓰기
  - 클래스를 만든 이후에 속성(property)를 몇 개라도 자유롭게 정의하고 정의된 것을 사용할 수 있지만, 정의되지 않은 속성을 사용하려고 하면 문제가 생김
  - **python의 캡슐화**
  - **슈퍼클래스 호출 방법**
  - raise and with

## 앞으로 더 공부가 필요한 것
  - null, None을 python에서 처리하는 방법
  - 고차함수, 데코레이터 이용하는 법
  - \*와 \*\* 사용방법
  - PEP3
  - 특수 메소드 오버라이딩
  - collection
  - 그외: ⌜알기 쉬운 파이썬⌟ Ch11~Ch13
  
***
***

파이썬에서 지역변수는 오로지 함수 내에서만 이용됨. **그렇지만 함수 내에서는 ★★매개변수로 받지 않고도 상위 네임스페이스의 변수를 참조할 수 있음. 그렇지만 변수의 값을 조작할 수는 없음. 그것을 위해서는 global을 써야함(global은 필요할 때마다 계속 써야함. 이게 다른 언어에서 call by reference라고 생각할 수 있지 않을까...). 이건 클래스도 마찬가지. 매개변수로 값을 전달하면 call by value★★ for이나 if블록에서 변수를 선언하면 그 변수는 블록 밖에서도 사용 가능** // 요약하기.